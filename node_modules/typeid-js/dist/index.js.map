{"version":3,"sources":["../src/index.ts","../src/typeid.ts","../src/parse_uuid.ts","../src/base32.ts","../src/unboxed/typeid.ts","../src/prefix.ts","../src/unboxed/error.ts"],"sourcesContent":["export { typeid, TypeID } from \"./typeid\";\nexport {\n  type TypeId,\n  typeidUnboxed,\n  fromString,\n  parseTypeId,\n  getType,\n  getSuffix,\n  toUUIDBytes,\n  toUUID,\n  fromUUIDBytes,\n  fromUUID,\n} from \"./unboxed/typeid\";\n","import { stringify } from \"uuid\";\nimport { parseUUID } from \"./parse_uuid\";\nimport { encode, decode } from \"./base32\";\nimport {\n  typeidUnboxed,\n  getSuffix,\n  getType,\n  fromString,\n} from \"./unboxed/typeid\";\nimport { TypeIDConversionError } from \"./unboxed/error\";\n\nexport class TypeID<const T extends string> {\n  constructor(private prefix: T, private suffix: string = \"\") {\n    const typeIdRaw = typeidUnboxed(prefix, suffix);\n\n    this.prefix = getType(typeIdRaw);\n    this.suffix = getSuffix(typeIdRaw);\n  }\n\n  public getType(): T {\n    return this.prefix;\n  }\n\n  public getSuffix(): string {\n    return this.suffix;\n  }\n\n  public asType<const U extends string>(prefix: U): TypeID<U> {\n    const self = this as unknown as TypeID<U>;\n    if (self.prefix !== prefix) {\n      throw new TypeIDConversionError(self.prefix, prefix);\n    }\n    return self;\n  }\n\n  public toUUIDBytes(): Uint8Array {\n    return decode(this.suffix);\n  }\n\n  public toUUID(): string {\n    return stringify(this.toUUIDBytes());\n  }\n\n  public toString(): T extends \"\" ? string : `${T}_${string}` {\n    if (this.prefix === \"\") {\n      return this.suffix as T extends \"\" ? string : `${T}_${string}`;\n    }\n    return `${this.prefix}_${this.suffix}` as T extends \"\" ? string : `${T}_${string}`;\n  }\n\n  static fromString<const T extends string>(\n    str: string,\n    prefix?: T\n  ): TypeID<T> {\n    const typeIdRaw = fromString(str, prefix);\n\n    return new TypeID<T>(getType(typeIdRaw) as T, getSuffix(typeIdRaw));\n  }\n\n  static fromUUIDBytes<const T extends string>(\n    prefix: T,\n    bytes: Uint8Array\n  ): TypeID<T> {\n    const suffix = encode(bytes);\n    return new TypeID(prefix, suffix);\n  }\n\n  static fromUUID<const T extends string>(prefix: T, uuid: string): TypeID<T> {\n    const suffix = encode(parseUUID(uuid));\n    return new TypeID(prefix, suffix);\n  }\n}\n\nexport function typeid<T extends string>(): TypeID<\"\">;\nexport function typeid<T extends string>(prefix: T): TypeID<T>;\nexport function typeid<T extends string>(prefix: T, suffix: string): TypeID<T>;\nexport function typeid<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeID<T> {\n  return new TypeID(prefix, suffix);\n}\n","/* eslint-disable no-bitwise */\nexport function parseUUID(uuid: string) {\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Block 1\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = (v >>> 16) & 0xff;\n  arr[2] = (v >>> 8) & 0xff;\n  arr[3] = v & 0xff;\n\n  // Block 2\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Block 3\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Block 4\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Block 5\n  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;\n  arr[11] = (v / 0x100000000) & 0xff;\n  arr[12] = (v >>> 24) & 0xff;\n  arr[13] = (v >>> 16) & 0xff;\n  arr[14] = (v >>> 8) & 0xff;\n  arr[15] = v & 0xff;\n\n  return arr;\n}\n","/* eslint-disable no-bitwise */\nconst alphabet: string = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n// Decoding table\nconst dec: Uint8Array = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03,\n  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n  0x11, 0xff, 0x12, 0x13, 0xff, 0x14, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,\n  0xff, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n]);\n\nexport function encode(src: Uint8Array): string {\n  const dst: string[] = new Array(26).fill(\"\");\n\n  if (src.length !== 16) {\n    throw new Error(\n      `Invalid length. Expected 16 bytes, got ${src.length}. Input: ${src}`\n    );\n  }\n\n  // 10 byte timestamp\n  dst[0] = alphabet[(src[0] & 224) >> 5];\n  dst[1] = alphabet[src[0] & 31];\n  dst[2] = alphabet[(src[1] & 248) >> 3];\n  dst[3] = alphabet[((src[1] & 7) << 2) | ((src[2] & 192) >> 6)];\n  dst[4] = alphabet[(src[2] & 62) >> 1];\n  dst[5] = alphabet[((src[2] & 1) << 4) | ((src[3] & 240) >> 4)];\n  dst[6] = alphabet[((src[3] & 15) << 1) | ((src[4] & 128) >> 7)];\n  dst[7] = alphabet[(src[4] & 124) >> 2];\n  dst[8] = alphabet[((src[4] & 3) << 3) | ((src[5] & 224) >> 5)];\n  dst[9] = alphabet[src[5] & 31];\n\n  // 16 bytes of randomness\n  dst[10] = alphabet[(src[6] & 248) >> 3];\n  dst[11] = alphabet[((src[6] & 7) << 2) | ((src[7] & 192) >> 6)];\n  dst[12] = alphabet[(src[7] & 62) >> 1];\n  dst[13] = alphabet[((src[7] & 1) << 4) | ((src[8] & 240) >> 4)];\n  dst[14] = alphabet[((src[8] & 15) << 1) | ((src[9] & 128) >> 7)];\n  dst[15] = alphabet[(src[9] & 124) >> 2];\n  dst[16] = alphabet[((src[9] & 3) << 3) | ((src[10] & 224) >> 5)];\n  dst[17] = alphabet[src[10] & 31];\n  dst[18] = alphabet[(src[11] & 248) >> 3];\n  dst[19] = alphabet[((src[11] & 7) << 2) | ((src[12] & 192) >> 6)];\n  dst[20] = alphabet[(src[12] & 62) >> 1];\n  dst[21] = alphabet[((src[12] & 1) << 4) | ((src[13] & 240) >> 4)];\n  dst[22] = alphabet[((src[13] & 15) << 1) | ((src[14] & 128) >> 7)];\n  dst[23] = alphabet[(src[14] & 124) >> 2];\n  dst[24] = alphabet[((src[14] & 3) << 3) | ((src[15] & 224) >> 5)];\n  dst[25] = alphabet[src[15] & 31];\n\n  return dst.join(\"\");\n}\n\nexport function decode(s: string): Uint8Array {\n  if (s.length !== 26) {\n    throw new Error(\n      `Invalid length. Expected 26 bytes, got ${s.length}. Input: ${s}`\n    );\n  }\n\n  const encoder = new TextEncoder();\n  const v: Uint8Array = encoder.encode(s);\n\n  // Check if all the characters are part of the expected base32 character set.\n  if (\n    dec[v[0]] === 0xff ||\n    dec[v[1]] === 0xff ||\n    dec[v[2]] === 0xff ||\n    dec[v[3]] === 0xff ||\n    dec[v[4]] === 0xff ||\n    dec[v[5]] === 0xff ||\n    dec[v[6]] === 0xff ||\n    dec[v[7]] === 0xff ||\n    dec[v[8]] === 0xff ||\n    dec[v[9]] === 0xff ||\n    dec[v[10]] === 0xff ||\n    dec[v[11]] === 0xff ||\n    dec[v[12]] === 0xff ||\n    dec[v[13]] === 0xff ||\n    dec[v[14]] === 0xff ||\n    dec[v[15]] === 0xff ||\n    dec[v[16]] === 0xff ||\n    dec[v[17]] === 0xff ||\n    dec[v[18]] === 0xff ||\n    dec[v[19]] === 0xff ||\n    dec[v[20]] === 0xff ||\n    dec[v[21]] === 0xff ||\n    dec[v[22]] === 0xff ||\n    dec[v[23]] === 0xff ||\n    dec[v[24]] === 0xff ||\n    dec[v[25]] === 0xff\n  ) {\n    throw new Error(\"Invalid base32 character\");\n  }\n\n  const id = new Uint8Array(16);\n\n  // 6 bytes timestamp (48 bits)\n  id[0] = (dec[v[0]] << 5) | dec[v[1]];\n  id[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2);\n  id[2] = ((dec[v[3]] & 3) << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4);\n  id[3] = ((dec[v[5]] & 15) << 4) | (dec[v[6]] >> 1);\n  id[4] = ((dec[v[6]] & 1) << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3);\n  id[5] = ((dec[v[8]] & 7) << 5) | dec[v[9]];\n\n  // 10 bytes of entropy (80 bits)\n  id[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2);\n  id[7] = ((dec[v[11]] & 3) << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4);\n  id[8] = ((dec[v[13]] & 15) << 4) | (dec[v[14]] >> 1);\n  id[9] = ((dec[v[14]] & 1) << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3);\n  id[10] = ((dec[v[16]] & 7) << 5) | dec[v[17]];\n  id[11] = (dec[v[18]] << 3) | (dec[v[19]] >> 2);\n  id[12] = ((dec[v[19]] & 3) << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4);\n  id[13] = ((dec[v[21]] & 15) << 4) | (dec[v[22]] >> 1);\n  id[14] = ((dec[v[22]] & 1) << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3);\n  id[15] = ((dec[v[24]] & 7) << 5) | dec[v[25]];\n\n  return id;\n}\n","import { stringify, v7 } from \"uuid\";\nimport { parseUUID } from \"../parse_uuid\";\nimport { encode, decode } from \"../base32\";\nimport { isValidPrefix } from \"../prefix\";\nimport {\n  EmptyPrefixError,\n  InvalidPrefixError,\n  InvalidSuffixCharacterError,\n  InvalidSuffixLengthError,\n  PrefixMismatchError,\n} from \"./error\";\n\nexport type TypeId<T> = string & { __type: T };\n\nexport function typeidUnboxed<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeId<T> {\n  if (!isValidPrefix(prefix)) {\n    throw new InvalidPrefixError(prefix);\n  }\n\n  let finalSuffix: string;\n  if (suffix) {\n    finalSuffix = suffix;\n  } else {\n    const buffer = new Uint8Array(16);\n    v7(undefined, buffer);\n    finalSuffix = encode(buffer);\n  }\n\n  if (finalSuffix.length !== 26) {\n    throw new InvalidSuffixLengthError(finalSuffix.length);\n  }\n\n  if (finalSuffix[0] > \"7\") {\n    throw new InvalidSuffixCharacterError(finalSuffix[0]);\n  }\n\n  // Validate the suffix by decoding it. If it's invalid, an error will be thrown.\n  decode(finalSuffix);\n\n  if (prefix === \"\") {\n    return finalSuffix as TypeId<T>;\n  } else {\n    return `${prefix}_${finalSuffix}` as TypeId<T>;\n  }\n}\n\n/**\n * Constructs a TypeId from a string representation, optionally validating against a provided prefix.\n * This function splits the input `typeId` string by an underscore `_` to separate the prefix and suffix.\n * If the `typeId` contains no underscore, it is assumed to be a suffix with an empty prefix.\n * If a `prefix` is provided, it must match the prefix part of the `typeId`, or an error is thrown.\n *\n * @param {string} typeId - The string representation of the TypeId to be parsed.\n * @param {T} [prefix] - An optional prefix to validate against the prefix in the `typeId`.\n * @returns {TypeId<T>} A new TypeId instance constructed from the parsed `typeId`.\n * @throws {Error} If the `typeId` format is invalid, the prefix is empty when there's a separator,\n *                 or there's a prefix mismatch when a `prefix` is provided.\n * @template T - A string literal type that extends string.\n */\nexport function fromString<T extends string>(\n  typeId: string,\n  prefix?: T\n): TypeId<T> {\n  let p;\n  let s;\n\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    p = \"\" as T;\n    s = typeId;\n  } else {\n    p = typeId.substring(0, underscoreIndex) as T;\n    s = typeId.substring(underscoreIndex + 1);\n\n    if (!p) {\n      throw new EmptyPrefixError(typeId);\n    }\n  }\n\n  if (!s) {\n    throw new InvalidSuffixLengthError(0);\n  }\n\n  if (prefix && p !== prefix) {\n    throw new PrefixMismatchError(prefix, p);\n  }\n\n  return typeidUnboxed(p, s);\n}\n\n/**\n * Parses a TypeId string into its prefix and suffix components.\n *\n * @param {TypeId<T>} typeId - The TypeId string to parse.\n * @returns {{ prefix: T; suffix: string }} An object containing the prefix and suffix of the TypeId.\n * @throws {Error} If the TypeId format is invalid (not exactly two parts separated by an underscore).\n *\n * @example\n * // For a valid TypeId 'example_00041061050r3gg28a1c60t3gf'\n * const { prefix, suffix } = parseTypeId('example_00041061050r3gg28a1c60t3gf');\n * console.log(prefix); // 'example'\n * console.log(suffix); // '00041061050r3gg28a1c60t3gf'\n *\n * @example\n * // Throws an error for invalid TypeId format\n * try {\n *   parseTypeId('invalidTypeId');\n * } catch (error) {\n *   console.error(error.message); // 'Invalid TypeId format: invalidTypeId'\n * }\n */\nexport function parseTypeId<T extends string>(\n  typeId: TypeId<T>\n): { prefix: T; suffix: string } {\n  return { prefix: getType(typeId), suffix: getSuffix(typeId) };\n}\n\n/**\n * Retrieves the prefix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the prefix.\n * @returns {T} The prefix of the TypeId.\n */\nexport function getType<T extends string>(typeId: TypeId<T>): T {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return \"\" as T;\n  }\n  return typeId.substring(0, underscoreIndex) as T;\n}\n\n/**\n * Retrieves the suffix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the suffix.\n * @returns {string} The suffix of the TypeId.\n */\nexport function getSuffix<T extends string>(typeId: TypeId<T>): string {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return typeId;\n  }\n  return typeId.substring(underscoreIndex + 1);\n}\n\nexport function toUUIDBytes<T extends string>(typeId: TypeId<T>): Uint8Array {\n  return decode(getSuffix(typeId));\n}\n\nexport function toUUID<T extends string>(typeId: TypeId<T>) {\n  return stringify(toUUIDBytes(typeId));\n}\n\nexport function fromUUIDBytes(\n  prefix: string,\n  bytes: Uint8Array\n): TypeId<typeof prefix> {\n  const suffix = encode(bytes);\n  return prefix\n    ? (`${prefix}_${suffix}` as TypeId<typeof prefix>)\n    : (suffix as TypeId<typeof prefix>);\n}\n\nexport function fromUUID<T extends string>(\n  uuid: string,\n  prefix?: T\n): TypeId<T> {\n  const suffix = encode(parseUUID(uuid));\n  return prefix ? (`${prefix}_${suffix}` as TypeId<T>) : (suffix as TypeId<T>);\n}\n","export function isValidPrefix(str: string): boolean {\n  if (str.length > 63) {\n    return false;\n  }\n\n  let code;\n  let i;\n  let len;\n\n  for (i = 0, len = str.length; i < len; i += 1) {\n    code = str.charCodeAt(i);\n    const isLowerAtoZ = code > 96 && code < 123;\n    const isUnderscore = code === 95;\n\n    // first and last char of prefix can only be [a-z]\n    if ((i === 0 || i === len - 1) && !isLowerAtoZ) {\n      return false;\n    }\n\n    if (!(isLowerAtoZ || isUnderscore)) {\n      return false;\n    }\n  }\n  return true;\n}\n","export class InvalidPrefixError extends Error {\n  constructor(prefix: string) {\n    super(`Invalid prefix \"${prefix}\". Must be at most 63 ASCII letters [a-z_]`);\n    this.name = \"InvalidPrefixError\";\n  }\n}\n\nexport class PrefixMismatchError extends Error {\n  constructor(expected: string, actual: string) {\n    super(`Invalid TypeId. Prefix mismatch. Expected ${expected}, got ${actual}`);\n    this.name = \"PrefixMismatchError\";\n  }\n}\n\nexport class EmptyPrefixError extends Error {\n  constructor(typeId: string) {\n    super(`Invalid TypeId. Prefix cannot be empty when there's a separator: ${typeId}`);\n    this.name = \"EmptyPrefixError\";\n  }\n}\n\nexport class InvalidSuffixLengthError extends Error {\n  constructor(length: number) {\n    super(`Invalid length. Suffix should have 26 characters, got ${length}`);\n    this.name = \"InvalidSuffixLengthError\";\n  }\n}\n\nexport class InvalidSuffixCharacterError extends Error {\n  constructor(firstChar: string) {\n    super(`Invalid suffix. First character \"${firstChar}\" must be in the range [0-7]`);\n    this.name = \"InvalidSuffixCharacterError\";\n  }\n}\n\nexport class TypeIDConversionError extends Error {\n  constructor(actualPrefix: string, expectedPrefix: string) {\n    super(`Cannot convert TypeID of type ${actualPrefix} to type ${expectedPrefix}`);\n    this.name = \"TypeIDConversionError\";\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAA,eAA0B;;;ACCnB,SAAS,UAAU,MAAc;AACtC,MAAI;AACJ,QAAM,MAAM,IAAI,WAAW,EAAE;AAG7B,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,GAAG,CAAC,GAAG,EAAE,OAAO;AAClD,MAAI,CAAC,IAAK,MAAM,KAAM;AACtB,MAAI,CAAC,IAAK,MAAM,IAAK;AACrB,MAAI,CAAC,IAAI,IAAI;AAGb,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,GAAG,EAAE,GAAG,EAAE,OAAO;AACnD,MAAI,CAAC,IAAI,IAAI;AAGb,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,IAAI,EAAE,GAAG,EAAE,OAAO;AACpD,MAAI,CAAC,IAAI,IAAI;AAGb,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,IAAI,EAAE,GAAG,EAAE,OAAO;AACpD,MAAI,CAAC,IAAI,IAAI;AAGb,MAAI,EAAE,KAAM,IAAI,SAAS,KAAK,MAAM,IAAI,EAAE,GAAG,EAAE,KAAK,gBAAiB;AACrE,MAAI,EAAE,IAAK,IAAI,aAAe;AAC9B,MAAI,EAAE,IAAK,MAAM,KAAM;AACvB,MAAI,EAAE,IAAK,MAAM,KAAM;AACvB,MAAI,EAAE,IAAK,MAAM,IAAK;AACtB,MAAI,EAAE,IAAI,IAAI;AAEd,SAAO;AACT;;;AC/BA,IAAM,WAAmB;AAGzB,IAAM,MAAkB,IAAI,WAAW;AAAA,EACrC;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;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","names":["import_uuid"]}