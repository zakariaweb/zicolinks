import { createPromiseClient } from '@connectrpc/connect';
import { ArcjetStackToProtocol, ArcjetDecisionToProtocol, ArcjetRuleToProtocol, ArcjetDecisionFromProtocol } from './convert.js';
import 'typeid-js';
import { ReportRequest, DecideRequest } from './proto/decide/v1alpha1/decide_pb.js';
import { DecideService } from './proto/decide/v1alpha1/decide_connect.js';

// TODO: Dedupe with `errorMessage` in core
function errorMessage(err) {
    if (err) {
        if (typeof err === "string") {
            return err;
        }
        if (typeof err === "object" &&
            "message" in err &&
            typeof err.message === "string") {
            return err.message;
        }
    }
    return "Unknown problem";
}
function createClient(options) {
    const { transport, sdkVersion, baseUrl, timeout } = options;
    const sdkStack = ArcjetStackToProtocol(options.sdkStack);
    const client = createPromiseClient(DecideService, transport);
    return Object.freeze({
        async decide(context, details, rules) {
            const { log } = context;
            let hasValidateEmail = false;
            const protoRules = [];
            for (const rule of rules) {
                if (rule.type === "EMAIL") {
                    hasValidateEmail = true;
                }
                protoRules.push(ArcjetRuleToProtocol(rule));
            }
            // Build the request object from the Protobuf generated class.
            const decideRequest = new DecideRequest({
                sdkStack,
                sdkVersion,
                characteristics: context.characteristics,
                details: {
                    ip: details.ip,
                    method: details.method,
                    protocol: details.protocol,
                    host: details.host,
                    path: details.path,
                    headers: Object.fromEntries(details.headers.entries()),
                    cookies: details.cookies,
                    query: details.query,
                    // TODO(#208): Re-add body
                    // body: details.body,
                    extra: details.extra,
                    email: typeof details.email === "string" ? details.email : undefined,
                },
                rules: protoRules,
            });
            log.debug("Decide request to %s", baseUrl);
            const response = await client.decide(decideRequest, {
                headers: { Authorization: `Bearer ${context.key}` },
                // If an email rule is configured, we double the timeout.
                // See https://github.com/arcjet/arcjet-js/issues/1697
                timeoutMs: hasValidateEmail ? timeout * 2 : timeout,
            });
            const decision = ArcjetDecisionFromProtocol(response.decision);
            log.debug({
                id: decision.id,
                fingerprint: context.fingerprint,
                path: details.path,
                runtime: context.runtime,
                ttl: decision.ttl,
                conclusion: decision.conclusion,
                reason: decision.reason,
                ruleResults: decision.results,
            }, "Decide response");
            return decision;
        },
        report(context, details, decision, rules) {
            const { log } = context;
            // Build the request object from the Protobuf generated class.
            const reportRequest = new ReportRequest({
                sdkStack,
                sdkVersion,
                characteristics: context.characteristics,
                details: {
                    ip: details.ip,
                    method: details.method,
                    protocol: details.protocol,
                    host: details.host,
                    path: details.path,
                    headers: Object.fromEntries(details.headers.entries()),
                    cookies: details.cookies,
                    query: details.query,
                    // TODO(#208): Re-add body
                    // body: details.body,
                    extra: details.extra,
                    email: typeof details.email === "string" ? details.email : undefined,
                },
                decision: ArcjetDecisionToProtocol(decision),
                rules: rules.map(ArcjetRuleToProtocol),
            });
            log.debug("Report request to %s", baseUrl);
            // We use the promise API directly to avoid returning a promise from this
            // function so execution can't be paused with `await`
            const reportPromise = client
                .report(reportRequest, {
                headers: { Authorization: `Bearer ${context.key}` },
                // Rules don't execute during `Report` so we don't adjust the timeout
                // if an email rule is configured.
                timeoutMs: 2_000, // 2 seconds
            })
                .then((response) => {
                log.debug({
                    id: decision.id,
                    fingerprint: context.fingerprint,
                    path: details.path,
                    runtime: context.runtime,
                    ttl: decision.ttl,
                }, "Report response");
            })
                .catch((err) => {
                log.info("Encountered problem sending report: %s", errorMessage(err));
            });
            if (typeof context.waitUntil === "function") {
                context.waitUntil(reportPromise);
            }
        },
    });
}

export { createClient };
